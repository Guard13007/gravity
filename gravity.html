<!DOCTYPE html>
<html>
<head>
<title>Gravity</title>
<link rel="stylesheet" type="text/css" href="css/style.css" />
<script type="text/javascript" src="js/colliders.js"></script>
<script type="text/javascript" src="js/debug.js"></script>
<script type="text/javascript" src="js/environment.js"></script>
<script type="text/javascript" src="js/main.js"></script>
<script type="text/javascript" src="js/rendering.js"></script>
</head>
<body>
<center>
<h1 id="title">Gravity</h1>
<canvas id="canvas" width="560" height="440">If you can see this, something went wrong.</canvas>
<div id="logdiv"><p id="out"></p></div>
<input name="text" type="textarea" id="in" onkeyup="consoleInput(event);" />
<div id="playerStats"></div>
<div id="debug"></div>
</center>
<script>

var canvas=document.getElementById("canvas");
var context=canvas.getContext("2d");
var objects=new Array();

// For console div:
var logdiv = document.getElementById("logdiv");

// RUNNING SPEED VARIABLES
var runSpeed=10;     // how many milliseconds between each iteration
var hyperWarp=false; // simulation is run multiple times per iteration
                     // WARNING: Messing with this can freeze or crash your browser.
var hyperSpeed=20;   // how many times to run simulation per iteration
                     // WARNING: High values lead to lag, freezing, crashing.
var timeStep=0.5;    // multipled by velocity/movement to change accuracy/speed of the simulation
                     // (lower is more accurate, but slower)

// PLAYER RELATED VARIABLES
var playerId=0;      // ID of Thing that is the player

// RENDER RELATED VARIABLES
var hyperRender=true; //True=normal render, False=rendering ONLY WORKS with hyperWarp on, and at runSpeed
var scaleFactor=1;  // multiplied by data in rendering to adjust zoom level
var renderRadius=1; // minimum render radius for an object
var renderId=0;     // ID of Thing to put at center of frame
var parentId=0;     // ID of Thing to use as parent body (for rotating frame of reference)
var parentRotation=true; // whether to rotate based on angle between parentId and renderId (true),
                        // or using the rotation of renderId (false)
var renderType="norm"; // "norm" shows top-down, "side" shows a sideview (1D), "3D" shows fake-3D
var path=true;      // draw path? [by not clearing canvas]
var pathFade=true;  // path fades away over time?
var fadeAlpha=0.05; // how much fade per iteration
var zoom=false;     // zoom in slowly? (just for the hell of it)
var zoomFactor=1;   // how much to increase scaleFactor each frame when zoom is on

// CONSTANTS
var version="0.1.0"  //Yes, there is a version number now. Don't know why.
var G;               //Gravitational Constant
var iLastVelocity=0; //used to find SoI
var jLastVelocity=0;



//Math.Tau=2*Math.PI;
document.getElementById("title").innerHTML+=" "+version;
Environments();
verga(); // Final system to be used in the game.
//stableySystem(); // two planets, moon and asteroid that get kicked out of system
//collidingSystem(); // for testing collisions
//unstableSystem(); // stableySystem, but with lots of extra stuff to unstablize it
//orbitalVelocityTest(); // testing the function to set velocities for circular orbits
start();



// These two functions need to be moved into a different file somehow.

function setOrbitalVelocity(id,d)
{
    //id=parent body id, d=radius of orbit (distance)
    //change to set this value relative to the parent body, applying any accelerations to the parent to the child
    var result=Math.sqrt(G*objects[id].m/(d*1.25));
    consoleOutput("Calculated orbital velocity: "+result,"Calculated orbital velocity: "+result);
    return result;
}

function Thing(m,x,y,Vx,Vy,color,radius,name,rotation)
{
    !name ? this.name="unnamed" : this.name=name;
    this.m=m;                                                     //mass
    !radius ? this.rad=Math.pow(m,1/3) : this.rad=radius;
    this.x=x;                                                     //location
    this.y=y;
    this.Vx=Vx;                                                   //velocity
    this.Vy=Vy;
    this.rot=0;                                                   //current rotation
    !rotation ? this.rotspd=0 : this.rotspd=rotation*Math.PI/180; //rotation speed
    !color ? this.fill="#FFFFFF" : this.fill=color;               //fill color
    this.fixed=false;
    this.collides=true;
    this.SoI;                                                     //ID of Thing in the SoI of
    
    this.getVelocity = function()
    {
        return Math.sqrt(this.Vx*this.Vx+this.Vy*this.Vy);
    }
    
    this.getOriginDistance = function()
    {
        return Math.sqrt(this.x*this.x+this.y*this.y);
    }
    
    this.dataOut = function()
    {
        return "<tr><td>Mass:<br />"+this.m.toFixed(3)+"</td><td>Radius:<br />"+this.rad.toFixed(3)+"</td><td>X: "+this.x.toFixed(2)+"<br />Y: "+this.y.toFixed(2)+"</td><td>Velocity X/Y:<br />"+this.Vx.toFixed(2)+" / "+this.Vy.toFixed(2)+"</td><td>Fill color:<br />"+this.fill+"</td><td>Fixed? "+this.fixed.toString()+"</td></tr>";
    }
}

</script>
</body>
</html>