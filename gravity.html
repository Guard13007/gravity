<!DOCTYPE html>
<html>
<head>
<title>Gravity</title>
<style>
body {
    background: #000000;
    color: #FFFFFF;
}
canvas {
    border: 3px #FFFFFF solid;
}
table {
    border: 1px #FFFFFF solid;
    width: 100%;
}
</style>
</head>
<body>
<center>
<h1>Gravity</h1>
<div id="playerStats"></div>
<canvas id="canvas" width="960" height="540"></canvas>
<div id="debug"></div>
</center>
<script>

//window.performance.now() - apparently something you can use to run faster than 1000x per second, but only in Chrome

var canvas=document.getElementById("canvas");
var context=canvas.getContext("2d");
var objects=new Array();

var runSpeed=20; // how many milliseconds between each iteration
var hyperWarp=false; // simulation is run multiple times per iteration     WARNING: Messing with this can freeze or crash your browser.
var hyperSpeed=20; // how many times to run simulation per iteration       WARNING: High values lead to lag, freezing, crashing.
var hyperRender=true; // True=normal render, False=rendering ONLY WORKS with hyperWarp on, and at regular runSpeed (aka slower)
var scaleFactor=0.8; //multiplied by data in rendering to adjust zoom level
var timeFactor=0.8; // multipled by velocity/movement to change how fast/"accurate" the simulation is
var path=true;  // draw path?

var playerId=1; // ID of Thing that is the player
var renderId=0; // ID of Thing to put at center of frame

initialize();

function initialize()
{
    //stableySystem(); // two planets, moon and asteroid that get kicked out of system
    //scaledSystem();  // same as above, but scaled up 10x, set scaleFactor to 0.1 to see better
    //collidingSystem(); // for testing collisions (use this to see what is wrong with the collider)
    unstableSystem(); // stableySystem, but with lots of extra stuff to unstablize it
    if (hyperWarp)
    {
        setInterval(function()
        {
            for (var i = 0; i < hyperSpeed; i++) loop();
            if (!hyperRender) {
                redraw();
                debugOut();
                playerOut();
            }
        },runSpeed);
    } else {
        setInterval("loop()",runSpeed);
    }
}

function loop()
{
    for (var i = 0; i < objects.length; i++) objects[i].gravity();
    for (var i = 0; i < objects.length; i++) objects[i].update();
    if (hyperRender) {
        redraw();
        debugOut();
        playerOut();
    }
}

function Thing(m,x,y,Vx,Vy,color,radius)
{
    this.m=m; //mass
    !radius ? this.rad=Math.sqrt(m)/2 : this.rad=radius;
    this.x=x; //location
    this.y=y;
    this.Vx=Vx; //velocity
    this.Vy=Vy;
    //this.rot=0; //rotation
    !color ? this.fill="#FFFFFF" : this.fill=color; //fill color
    this.fixed=false;
    //this.collides=true;
    
    this.gravity = function()
    {
        for (var i = 0; i < objects.length; i++)
        {
            if (!this.fixed)
            {
                if (objects[i]==this) continue;
                var Nx=false;
                var Ny=false;
                var Dx=this.x-objects[i].x; //get relative distances
                var Dy=this.y-objects[i].y;
                if (Dx < 0)
                {
                    Nx=true;                //fix negative distance (for calculations)
                    Dx=-Dx;
                }
                if (Dy < 0)
                {
                    Ny=true;
                    Dy=-Dy;
                }
                var g=10*objects[i].m/(Dx*Dx+Dy*Dy); //calculate gravitational acceleration
                var Ax=Dx*g/(Dx+Dy);  //solve for acceleration x
                var Ay=g-Ax;          //      for              y
                if (Nx) Ax=-Ax; //fix negative values
                if (Ny) Ay=-Ay;
                Ax=-Ax;         //fix antigravity
                Ay=-Ay;
                this.Vx+=Ax*timeFactor;  //apply change of velocity
                this.Vy+=Ay*timeFactor;
            }
        }
    }
    
    this.update = function()
    {
        //Movement:
        if (!this.fixed)
        {
            this.x+=this.Vx*timeFactor; //apply acceleration
            this.y+=this.Vy*timeFactor;
        }
        // Collider:
        for (var j = objects.length-1; j > 0; j--)
        {
            if (objects[j]==this) continue;
            var Dx=this.x-objects[j].x; //find distances
            var Dy=this.y-objects[j].y;
            var d=Math.sqrt(Dx*Dx+Dy*Dy);
            if (d < this.rad+objects[j].rad) //if within both objects' radius', collided
            {
                //if (!this.collides) continue;
                //console.log("Collision between "+this+" and "+objects[j]+".");
                var Vx=this.Vx-objects[j].Vx; //get relative velocity
                var Vy=this.Vy-objects[j].Vy;
                var Fx=Vx*objects[j].m; // get force of objects[j]
                var Fy=Vy*objects[j].m;
                this.Vx-=Fx/this.m; //apply force from objects[j]
                this.Vy-=Fy/this.m;
                this.m+=objects[j].m; //add mass
                if (objects[j].rad > 1) this.rad=this.rad+Math.sqrt(objects[j].rad/4);
                if (renderId == j) renderId=objects.indexOf(this); // fix renderId if needed
                if (renderId > j) renderId-=1;
                objects.splice(j, 1); //delete objects[j]
            }
        }
    }
    
    this.getVelocity = function()
    {
        //idea: multiply this by 1000 for a pseudo-m/s velocity reading?
        return Math.abs(this.Vx)+Math.abs(this.Vy);
    }
    
    this.getOriginDistance = function()
    {
        return Math.sqrt(this.x*this.x+this.y*this.y);
    }
    
    this.dataOut = function()
    {
        return "<tr><td>Mass: "+this.m.toString()+"</td><td>Radius: "+this.rad.toFixed(2)+"</td><td>X: "+this.x.toFixed(2)+"</td><td>Y: "+this.y.toFixed(2)+"</td><td>Velocity X: "+this.Vx.toFixed(2)+"</td><td>Velocity Y: "+this.Vy.toFixed(2)+"</td><td>Fill color: "+this.fill+"</td><td>Fixed? "+this.fixed.toString()+"</td></tr>";
    }
}

function redraw()
{
    if (!path) context.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
    for (var i = 0; i < objects.length; i++)
    {
        context.beginPath();
        var radius=objects[i].rad*scaleFactor;
        if (radius < 0.5) radius=0.5;
        context.arc((objects[i].x-objects[renderId].x)*scaleFactor+canvas.clientWidth/2,(objects[i].y-objects[renderId].y)*scaleFactor+canvas.clientHeight/2,radius,0,2*Math.PI,false);
        context.fillStyle=objects[i].fill;
        context.fill();
    }
}

function playerOut()
{
    var out="<table>"+objects[playerId].dataOut()+"<tr><td colspan='3'>Total velocity: "+objects[playerId].getVelocity()+"</td><td colspan='5'>Distance from origin: "+objects[playerId].getOriginDistance()+"</td></tr></table>";
    document.getElementById("playerStats").innerHTML = out;
}

function debugOut()
{
    var out="<table>"
    for (var i = 0; i < objects.length; i++)
    {
        var out=out+objects[i].dataOut();
    }
    document.getElementById("debug").innerHTML = out+"</table>";
}

function stableySystem()
{
    //(0.62 scaleFactor minimum for full view)
    objects[0]=new Thing(100,0,0,0,0,"yellow");
    objects[0].fixed=true;
    objects[1]=new Thing(10,50,0,0,-4,"green");
    objects[2]=new Thing(0.005,180,0,0,2.32,"#6A6A87",1);
    objects[3]=new Thing(26,400,0,0,-1.5,"red");
    objects[4]=new Thing(0.01,420,0,0,-4,"blue",1);
}

function scaledSystem()
{
    //When scaling mass and distance equally, velocities do not scale.
    objects[0]=new Thing(1000,0,0,0,0,"yellow");
    objects[0].fixed=true;
    objects[1]=new Thing(100,500,0,0,-4,"green");
    objects[2]=new Thing(0.05,1800,0,0,2.32,"#6A6A87",1);
    objects[3]=new Thing(260,4000,0,0,-1.5,"red");
    objects[4]=new Thing(0.1,4200,0,0,-4,"blue",1);
}

function collidingSystem()
{
    objects[0]=new Thing(100,0,0,0,0,"yellow",12);
    objects[1]=new Thing(1,10,-70,0.2,0,"red",1);
    objects[2]=new Thing(20,120,10,0.1,0.1,"blue");
    objects[3]=new Thing(0.00001,-30,-30,0,0,false,1);
    objects[3].fixed=true;
    //objects[3].collides=false;
    objects[4]=new Thing(5,-120,-10,-0.2,0.1,"green",1.3);
    objects[5]=new Thing(1,-40,-70,-0.1,0.1,"#676789",1);
    objects[5]=new Thing(100,-200,-200,0,0,"yellow");
    objects[6]=new Thing(30,400,0,0.01,0.2,"red");
}

function unstableSystem()
{
    //(0.62 scaleFactor minimum for full view)
    objects[0]=new Thing(100,0,0,0,0,"yellow");
    objects[0].fixed=true;
    objects[1]=new Thing(10,50,0,0,-4,"green");
    objects[2]=new Thing(0.005,180,0,0,2.32,"#6A6A87",1);
    objects[3]=new Thing(26,400,0,0,-1.5,"red");
    objects[4]=new Thing(0.01,420,0,0,-4,"blue",1);
    objects[5]=new Thing(0.005,200,0,0,2.3,"#6A6A87",1);
    objects[6]=new Thing(0.005,160,0,0,2.51,"#6A6A87",1);
    objects[7]=new Thing(0.005,-180,0,0,-2.32,"#6A6A87",1);
    objects[8]=new Thing(0.009,-170,10,0,-2,"#6A6A87",1);
    objects[9]=new Thing(0.001,-300,40,0.4,-1.5,"#6A6A87",1);
    objects[10]=new Thing(0.08,100,0,0,-2.7,"#6A6A87",1);
}

//objects[i]=new Thing(mass,x,y,Vx,Vy,color,radius);

</script>
</body>
</html>