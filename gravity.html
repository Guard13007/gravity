<!DOCTYPE html>
<html>
<head>
<title>Gravity</title>
<style>
body {
    background: #000000;
    color: #FFFFFF;
}
canvas {
    border: 3px #FFFFFF solid;
    border-radius:10px;
}
table {
    border: 1px #FFFFFF solid;
    width: 100%;
    margin:6px;
}
</style>
</head>
<body>
<center>
<h1>Gravity</h1>
<div id="playerStats"></div>
<canvas id="canvas" width="620" height="440">If you can see this, something went wrong.</canvas>
<!--<canvas id="canvas" width="960" height="540"></canvas>-->
<div id="debug"></div>
</center>
<script>

//window.performance.now() - apparently something you can use to run faster than 1000x per second, but only in Chrome

var canvas=document.getElementById("canvas");
var context=canvas.getContext("2d");
var objects=new Array();

var runSpeed=40; // how many milliseconds between each iteration
var hyperWarp=false; // simulation is run multiple times per iteration     WARNING: Messing with this can freeze or crash your browser.
var hyperSpeed=20; // how many times to run simulation per iteration       WARNING: High values lead to lag, freezing, crashing.
var hyperRender=true; // True=normal render, False=rendering ONLY WORKS with hyperWarp on, and at runSpeed (aka slower)
var scaleFactor=0.5; //multiplied by data in rendering to adjust zoom level
var timeStep=0.8; // multipled by velocity/movement to change accuracy/speed of the simulation (lower is more accurate, but slower)
var renderRadius=1; // minimum render radius for an object
var path=true;  // draw path? [Don't clear canvas between draws.]

var playerId=1; // ID of Thing that is the player
var renderId=0; // ID of Thing to put at center of frame

var G; // Gravitational Constant

initialize();

function initialize()
{
    //stableySystem(); // two planets, moon and asteroid that get kicked out of system
    //collidingSystem(); // for testing collisions (use this to see what is wrong with the collider)
    unstableSystem(); // stableySystem, but with lots of extra stuff to unstablize it
    //realisticSystem(); // "realistic" my ass (also not finished in any way)
    if (hyperWarp)
    {
        setInterval(function()
        {
            for (var i = 0; i < hyperSpeed; i++) loop();
            if (!hyperRender) {
                redraw();
                debugOut();
                playerOut();
            }
        },runSpeed);
    } else {
        setInterval("loop()",runSpeed);
    }
}

function loop()
{
    for (var i = 0; i < objects.length-1; i++) for (var j = i+1; j < objects.length; j++) gravity(i,j);
    for (var i = 0; i < objects.length; i++) update(i);
    for (var i = objects.length-1; i > 0; i--) for (var j = i-1; j > -1; j--) collisionCheck(i,j);
    if (hyperRender) {
        redraw();
        debugOut();
        playerOut();
    }
}

function Thing(m,x,y,Vx,Vy,color,radius)
{
    this.m=m;                                             //mass
    !radius ? this.rad=Math.pow(m,1/3) : this.rad=radius;
    this.x=x;                                             //location
    this.y=y;
    this.Vx=Vx;                                           //velocity
    this.Vy=Vy;
    //this.rot=0;                                         //rotation
    !color ? this.fill="#FFFFFF" : this.fill=color;       //fill color
    this.fixed=false;
    this.collides=true;
    
    this.getVelocity = function()
    {
        return Math.abs(this.Vx)+Math.abs(this.Vy);
        //this velocity is not technically correct?? (think diagonal lines on grid paper vs straight lines of the same X+Y)
    }
    
    this.getOriginDistance = function()
    {
        return Math.sqrt(this.x*this.x+this.y*this.y);
    }
    
    this.dataOut = function()
    {
        return "<tr><td>Mass: "+this.m.toFixed(3)+"</td><td>Radius: "+this.rad.toFixed(2)+"</td><td>X: "+this.x.toFixed(2)+"</td><td>Y: "+this.y.toFixed(2)+"</td><td>Velocity X: "+this.Vx.toFixed(2)+"</td><td>Velocity Y: "+this.Vy.toFixed(2)+"</td><td>Fill color: "+this.fill+"</td><td>Fixed? "+this.fixed.toString()+"</td></tr>";
    }
}

function gravity(i,j)
{
    var Nx=false;
    var Ny=false;
    var Dx=objects[i].x-objects[j].x; //get relative distances
    var Dy=objects[i].y-objects[j].y;
    var Ds=Dx*Dx+Dy*Dy;               //note Ds is not Distance, but Distance^2
    //try adding some sort of collision detection that checks and appends collisions to a list/array/whatever to be handled after gravity finishes?
    if (Dx < 0)
    {
        Nx=true;                      //fix negative distance (for calculations)
        Dx=-Dx;
    }
    if (Dy < 0)
    {
        Ny=true;
        Dy=-Dy;
    }
    if (!objects[i].fixed)
    {
        var g=G*objects[j].m/Ds;     //calculate gravitational acceleration
        var Ax=Dx*g/(Dx+Dy);         //solve for acceleration x
        var Ay=g-Ax;                 //      for              y
        if (Nx) Ax=-Ax;              //fix negative values
        if (Ny) Ay=-Ay;
        //Ax=-Ax;                    //fix antigravity
        //Ay=-Ay;                    //I NEED to know why this is no longer needed (something to do with the new looping method)
        Ax=-Ax; //i<j always, so needs gravity reversed
        Ay=-Ay;
        objects[i].Vx+=Ax*timeStep;  //apply change of velocity
        objects[i].Vy+=Ay*timeStep;
    }
    if (!objects[j].fixed)
    {
        var g=G*objects[i].m/Ds;     //calculate gravitational acceleration
        var Ax=Dx*g/(Dx+Dy);         //solve for acceleration x
        var Ay=g-Ax;                 //      for              y
        if (Nx) Ax=-Ax;              //fix negative values
        if (Ny) Ay=-Ay;
        objects[j].Vx+=Ax*timeStep;  //apply change of velocity
        objects[j].Vy+=Ay*timeStep;
    }
}

function update(i)
{
    //needs to handle things like rotation here in the future??
    if (!objects[i].fixed)
    {
        objects[i].x+=objects[i].Vx*timeStep; //apply acceleration
        objects[i].y+=objects[i].Vy*timeStep;
    }
}

function collisionCheck(i,j)
{
    try
    {
        var Dx=objects[i].x-objects[j].x; //find distances
    }
    catch(err)
    {
        console.log("Error caught: "+err);
        return;
    }
    var Dy=objects[i].y-objects[j].y;
    var d=Math.sqrt(Dx*Dx+Dy*Dy);
    if (d < objects[i].rad+objects[j].rad)
    {
        //ADD HERE: undo gravity for last step between these two objects
        if (!objects[i].collides) 
        {
            console.log("Ignored collision between "+i+" and "+j+".");
            return;
        }
        if (!objects[j].collides)
        {
            console.log("Ignored collision between "+i+" and "+j+".");
            return;
        }
        console.log("Collision between "+i+" and "+j+".");
        if (objects[j].m > objects[i].m) objects[i].fill=objects[j].fill; // the color of the more massive object is kept
        if (renderId == j) renderId=i;                                    // fix renderId if needed
        if (renderId > j) renderId-=1;
        if (objects[i].fixed)
        {
            objects[i].m+=objects[j].m;                //add mass
            objects[i].rad=Math.pow(objects[i].m,1/3); //recalc radius
            objects.splice(j,1);                       //delete [j]
            return;
        }
        if (objects[j].fixed)
        {
            objects[i].m+=objects[j].m;                //add mass
            objects[i].x=objects[j].x;                 //move to correct position
            objects[i].y=objects[j].y;  //TMP NOTE: I MAY BE REMOVING THE "WRONG" OBJECT ALL ALONG, MAYBE IT WON'T BREAK IF I START REMOVING [I] INSTEAD??
            objects[i].Vx=0;                           //correct the velocity
            objects[i].Vy=0;
            objects[i].rad=Math.pow(objects[i].m,1/3); //radius recalculated
            objects[i].fixed=true;                     //become fixed
            objects.splice(j,1);                       //delete [j]
            return;
        }
        var Lx=objects[i].x*objects[i].m+objects[j].x*objects[j].m;   //weighting the mass vs location to find the CoM
        var Ly=objects[i].y*objects[i].m+objects[j].y*objects[j].m;
        var Fx=objects[i].Vx*objects[i].m+objects[j].Vx*objects[j].m; //calculate force to apply to "new" object
        var Fy=objects[i].Vy*objects[i].m+objects[j].Vy*objects[j].m;
        objects[i].m+=objects[j].m;                //add mass of [j]
        objects[i].Vx=Fx/objects[i].m;             //apply combined force
        objects[i].Vy=Fy/objects[i].m;
        objects[i].rad=Math.pow(objects[i].m,1/3); //recalculate radius based on new mass
        objects[i].x=Lx/objects[i].m;              //find center of mass, place [i] there
        objects[i].y=Ly/objects[i].m;
        objects.splice(j,1);                       //delete [j]
    }
    /*
function gravity(i,j) //here temporarily, needs to be added to collider (or rather, the opposite of this)
{
    var Nx=false;
    var Ny=false;
    var Dx=objects[i].x-objects[j].x; //get relative distances
    var Dy=objects[i].y-objects[j].y;
    var Ds=Dx*Dx+Dy*Dy; //note Ds is not Distance, but Distance^2
    if (Dx < 0)
    {
        Nx=true;                      //fix negative distance (for calculations)
        Dx=-Dx;
    }
    if (Dy < 0)
    {
        Ny=true;
        Dy=-Dy;
    }
    if (!objects[i].fixed)
    {
        var g=G*objects[j].m/Ds; //calculate gravitational acceleration
        var Ax=Dx*g/(Dx+Dy); //solve for acceleration x
        var Ay=g-Ax;         //      for              y
        if (Nx) Ax=-Ax; //fix negative values
        if (Ny) Ay=-Ay;
        //Ax=-Ax;         //fix antigravity
        //Ay=-Ay;
        objects[i].Vx+=Ax*timeStep;  //apply change of velocity
        objects[i].Vy+=Ay*timeStep;
    }
}
    */
}

function redraw()
{
    if (!path) context.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
    for (var i = 0; i < objects.length; i++)
    {
        context.beginPath();
        var radius=objects[i].rad*scaleFactor;
        if (radius < renderRadius) radius=renderRadius;
        context.arc((objects[i].x-objects[renderId].x)*scaleFactor+canvas.clientWidth/2,(objects[i].y-objects[renderId].y)*scaleFactor+canvas.clientHeight/2,radius,0,2*Math.PI,false);
        context.fillStyle=objects[i].fill;
        context.fill();
    }
}

function playerOut()
{
    var out="<table>"+objects[playerId].dataOut()+"<tr><td colspan='4'>Total velocity: "+objects[playerId].getVelocity()+"</td><td colspan='4'>Distance from origin: "+objects[playerId].getOriginDistance()+"</td></tr></table>";
    document.getElementById("playerStats").innerHTML = out;
}

function debugOut()
{
    var out="<table>"
    for (var i = 0; i < objects.length; i++)
    {
        var out=out+objects[i].dataOut();
    }
    document.getElementById("debug").innerHTML = out+"</table>";
}

function stableySystem()
{
    G=10;
    //(0.6 scaleFactor minimum for full view)
    objects[0]=new Thing(100,0,0,0,0,"yellow");
    objects[0].fixed=true;
    objects[1]=new Thing(10,50,0,0,-4,"green");
    objects[2]=new Thing(0.005,180,0,0,2.32,"#6A6A87",1);
    objects[3]=new Thing(26,400,0,0,-1.5,"red");
    objects[4]=new Thing(0.01,420,0,0,-4,"blue",1);
}

function collidingSystem()
{
    G=10;
    objects[0]=new Thing(100,0,0,0,0,"yellow",12);
    objects[1]=new Thing(1,10,-70,0.2,0,"red",1);
    objects[2]=new Thing(20,120,10,0.1,0.1,"blue");
    objects[3]=new Thing(0.00001,-30,-30,0,0,false,0.5);
    objects[3].fixed=true;
    objects[3].collides=false;
    objects[4]=new Thing(5,-120,-10,-0.2,0.1,"green",1.3);
    objects[5]=new Thing(1,-40,-70,-0.1,0.1,"#676789",1);
    objects[5]=new Thing(100,-200,-200,0,0,"yellow");
    objects[6]=new Thing(30,400,0,0.01,0.2,"red");
}

function unstableSystem()
{
    G=10;
    //(0.6 scaleFactor minimum for full view)
    objects[0]=new Thing(100,0,0,0,0,"yellow");
    objects[0].fixed=true;
    objects[1]=new Thing(10,50,0,0,-4,"green");
    objects[2]=new Thing(0.005,180,0,0,2.32,"#6A6A87",1);
    objects[3]=new Thing(26,400,0,0,-1.5,"red");
    objects[4]=new Thing(0.01,420,0,0,-4,"blue",1);
    objects[5]=new Thing(0.005,200,0,0,2.3,"#6A6A87",1);
    objects[6]=new Thing(0.005,160,0,0,2.51,"#6A6A87",1);
    objects[7]=new Thing(0.005,-180,0,0,-2.32,"#6A6A87",1);
    objects[8]=new Thing(0.009,-170,10,0,-2,"#6A6A87",1);
    objects[9]=new Thing(0.001,-300,40,0.4,-1.5,"#6A6A87",1);
    objects[10]=new Thing(0.08,100,0,0,-2.7,"#6A6A87",1);
    objects[11]=new Thing(0.1,-400,10,0,1,"orange",2);
    objects[12]=new Thing(0.004,170,0,0,2.7,"#6A6A87",1);
    objects[13]=new Thing(0.006,140,16,0,2.51,"#6A6A87",1);
    objects[14]=new Thing(0.0032,-185,32,0,-2.32,"#6A6A87",1);
    objects[15]=new Thing(0.01,-100,10,0.4,-2.14,"#6A6A87",1);
    objects[16]=new Thing(0.0001,-325,42,0.32,-1.55,"#6A6A87",1);
    objects[17]=new Thing(0.082,105,-50,0.1,-2.7,"#6A6A87",1);
}

function realisticSystem()
{
    G=6.67384e-11; //real gravitational constant (probably needs to be higher, because I am using much smaller numbers)
    objects[0]=new Thing(90000,0,0,0,0,"yellow");
    objects[0].fixed=true;
    objects[1]=new Thing(100,1000,0,0,-20,"red");
}

//objects[i]=new Thing(mass,x,y,Vx,Vy,color,radius);

</script>
</body>
</html>